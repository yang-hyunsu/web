# 메서드 처리
1. 지식계열화
	1) 메서드의 기본 구성요소들을 만들 수 있다.
		리턴유형, 입력값(매개변수), 
		프로세스처리(저장, 조건/반복문처리, 화면출력)
		리턴값처리
	2) 메서드의 매개변수을 알고 메서드 오버로딩 규칙을 이해하고
		코딩할 수 있다.
	3) 매서드의 매개변수를 통해서 전역변수에 할당할 수 있고,
		그 지역변수와 전역변수를 이해하고 있다.
	4) 메서드의 리턴값 처리
		- 메서드에서 리턴타입과 리턴값의 의미를 이해하고 있고
			실제 데이터에 따라서 리턴데이터를 처리할 수 있다.
		- 메서드에 지역변수를 이용하여 리턴값을 처리할 수 있다.
		- 메서드에 전역변수를 이용하여 리턴값을 처리할 수 있다.
	5) 메서드 매개변수(입력값) + 리턴값 처리
	6) 메서드 매개변수(입력값) + 프로세스처리
		- 저장(지역변수/전역변수)
		- 조건/반복문처리
		- 화면출력 처리
	7) 메서드 매개변수(입력값) + 프로세스처리 + 리턴값처리

# 메서드 오버로딩
0. 변수와 비교 선언 규칙
	1) 변수 : 변수명 자체로 구분하여 동일한 변수를 중복불가
	2) 생성자/메서드 : 생성자/메서드명 + 매개변수 식별해서 선언한다..
1. 생성자의 오버로딩과 함께 메서드에서도 메서드명과 + 매개변수를 통해서,
	메서드를 선언할 수 있는 규칙을 말한다.
2. 아래와 같은 클래스내에서 동일한 이름의 메서드를 호출할 수 있는 규칙을 말한다.
	class MethodOverloading{
		String name;
		String name;(x)//변수명 동일한 이름으로 선언이 불가능
	
		// 메서드는 메서드명과 매개변수의 갯수, 타입, 순서로
		// 식별할 수 있을 때, 선언이 가능하다.
		void add(){
			System.out.println("매개변수가 없는 메서드");
		}
		void add(){ (x)
			System.out.println("매개변수가 없는 메서드");
		}		
		void add(int num01){
			System.out.println("매개변수가 1개 있는 메서드"+num01);
		}
		void add(double num01{
			System.out.println("매개변수가 타입이 다른 메서드"+num01);
		}
		void add(int num01, double num02){
			System.out.println("매개변수 순서1"+num01);
			System.out.println("매개변수 순서1"+num02);
		}
		void add(double num01, int num02){
			System.out.println("매개변수 순서2"+num01);
			System.out.println("매개변수 순서2"+num02);		
		}
	}
	main(){
		MethodOverloading m01 = new MethodOverloading();
		m01.add(); //
		m01.add(25); // 1. 매개변수의 갯수
		m01.add(25.75); // 2. 매개변수의 타입
		m01.add(25, 25.75); // 3. 매개변수의 타입의 순서
		m01.add(25.75, 25); // 4. 매개변수의 타입의 순서
		
	
	}	
# 메모리 발전
1. 하나의 변수 ==> 배열 ==> 클래스 ==> 객체안에 객체 ==> 객체안에
	배열형 객체.. 	
	
	
# 관계형 객체
1. 객체의 여러 관계를 통해서 효율적으로 객체지향적인 프로그램으로
	설계를 하고 처리를 할 수 있다.
2. 관계형 객체에서 다룰 개념
	1) 패키지개념 이해
		- 순수한 객체는 패키지명.클래스가 실제 객체의 이름이다.
		- 같은 패키지내에서 호출하는 객체
			패키지명을 생략하여도 호출이 가능하다.
			접근제어자가 public 아니더라도 접근이 가능하다.
			같은 패키지에 같은 클래스명을 선언하여 사용할 수 없다.
	 	- 다른 패키지에 있는 객체를 호출
	 	    1) 접근제어가 public이어야지 접근이 된다.
	 	    2) 외부에 패키지에 있는 클래스의 객체를 호출할 때는
	 	    	import하여야 한다.
	 	    	import를 하는 궁극적인 목적인 객체를 생성하거나
	 	    	선언하는 곳에서 패키지명 없이 사용하기 위한 목적이다.(사용자정의)
	 	    3) 동일한 곳에서 같은 이름의 클래스를 가지 다른 패키지의
	 	    	객체를 생성할려면 package명.클래스명의 형식으로
	 	    	객체를 생성하여야 한다.	
	 	    ex)
			javaexp.a08_relation.Person 
				p02 = new javaexp.a08_relation.Person();
	2) 접근제한자(접근제어자-access modifier)
		- 객체가 객체를 호출할 때, 객체의 구성요소에 
			대한 접근제어자의 범위 안에서 해당 객체의 구성요소를
			접근할 수 있다. ==> encapsulation 개념
		- 클래스의 구성요소에 따른 접근 제어 범위
			0) 접근제어범위 
				public : 어느 객체가 접근이 가능하게 선언
				protected : 상속한 객체만 외부패지에 있더라도 접근가능
				X(제어자가 붙지않는 경우) : 같은 패키지안에 있는 때만 접근 가능
				private : 다른 객체는 접근이 불가능하게 선언
		 	1) 접근제어 범위 선언 범위과 영향
		 		- 상위 블럭이 접근이 일단 되야 되고, 그 다음 하위 블럭의
		 			구성요소에 대한 접근 확인한다. 
		 		- 클래스 선언	
		 			public class 클래스명{}
		 			
		 			외부에서 객체를 선언할 때 영향을 미친다.
		 			Person p01; (접근가능)
		 			class 클래스명{}
		 			외부패키지안에 클래스에서 선언을 할 때, 호출을 하지 못한다.
		 			Person p02; X
		 			같은패키지에 있을 때만 접근이 가능하다.
		 			
		 			
		 		- 클래스내의 구성요소
		 			주의) 구성요소는 클래스 접근이 될 때,
		 			다시 접근제어자에 의해 가능한 경우에만 접근이된다.
		 			
		 			필드: private String name;
		 			생성자 : public Person(){}
		 			메서드 : public void show(){};	
			
			
			
	3) 객체안에 객체 호출(클래스 안에 다른 객체 호출 및 사용)
		- 1:1 객체 개념
		- 다중 객체 개념
		- 1:다 객체 개념	
ex)
	a05_pck
		Passenger
			선언
			Bus b1;
			Car c1;(X)
			void call(){
				b1 = new Bus(); (O)
				b1 = new Bus(7788); (x)
			    b1 = new Bus("서울행",9999) (O)
			    System.out.println(b1.no); (O)	
			    System.out.println(b1.target); (X)	
			}				
	a06_pck
		Bus
			no
			target
		Car	
	12:00~		 
			
			
		
		